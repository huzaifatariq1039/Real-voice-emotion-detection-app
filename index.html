<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Emotion Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            max-width: 800px;
            width: 90%;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #2d3748;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.recording {
            background: linear-gradient(45deg, #e53e3e, #ff6b6b);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .status {
            text-align: center;
            margin: 20px 0;
            font-size: 1.1em;
            color: #4a5568;
            min-height: 1.5em;
        }

        .results {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }

        .emotion-display {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border-radius: 15px;
            border: 3px solid;
        }

        .emotion-display.primary-emotion {
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        .current-emotion {
            font-size: 3em;
            margin-bottom: 10px;
            text-transform: capitalize;
            color: #2d3748;
            font-weight: bold;
            min-height: 1.2em;
        }

        .confidence {
            font-size: 1.4em;
            color: #667eea;
            font-weight: 600;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.8s ease;
            width: 0%;
        }

        .emotion-bars {
            margin-top: 30px;
        }

        .emotion-bars-title {
            text-align: center;
            font-size: 1.1em;
            color: #4a5568;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .emotion-bar {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .emotion-bar.primary {
            opacity: 1;
            transform: scale(1.02);
        }

        .emotion-label {
            width: 90px;
            text-align: right;
            margin-right: 15px;
            font-weight: 500;
            text-transform: capitalize;
            font-size: 0.9em;
        }

        .bar-container {
            flex: 1;
            height: 16px;
            background: #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 0.6s ease;
            position: relative;
        }

        .bar-text {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: #333;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
            min-width: 30px;
            text-align: center;
        }

        /* Emotion-specific colors */
        .emotion-happy .bar-fill { background: linear-gradient(90deg, #ffd89b, #19547b); }
        .emotion-sad .bar-fill { background: linear-gradient(90deg, #74b9ff, #0984e3); }
        .emotion-angry .bar-fill { background: linear-gradient(90deg, #fd79a8, #e84393); }
        .emotion-fearful .bar-fill { background: linear-gradient(90deg, #fdcb6e, #e17055); }
        .emotion-surprised .bar-fill { background: linear-gradient(90deg, #a29bfe, #6c5ce7); }
        .emotion-disgust .bar-fill { background: linear-gradient(90deg, #00b894, #00a085); }
        .emotion-calm .bar-fill { background: linear-gradient(90deg, #81ecec, #74b9ff); }
        .emotion-neutral .bar-fill { background: linear-gradient(90deg, #b2bec3, #636e72); }

        .file-upload {
            margin: 20px 0;
            text-align: center;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            background: linear-gradient(45deg, #00b894, #00a085);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .audio-visualizer {
            height: 100px;
            background: #f7fafc;
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(102, 126, 234, 0.2);
            position: relative;
            overflow: hidden;
        }

        .wave-bars {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 60px;
        }

        .wave-bar {
            width: 4px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 2px;
            animation: wave 1.5s ease-in-out infinite;
        }

        .wave-bar:nth-child(2n) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3n) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4n) { animation-delay: 0.3s; }

        @keyframes wave {
            0%, 100% { height: 10px; opacity: 0.3; }
            50% { height: 60px; opacity: 1; }
        }

        .message {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid;
        }

        .error {
            background: #fed7d7;
            color: #c53030;
            border-color: #feb2b2;
        }

        .info {
            background: #bee3f8;
            color: #2a69ac;
            border-color: #90cdf4;
        }

        .success {
            background: #c6f6d5;
            color: #22543d;
            border-color: #9ae6b4;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #666;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e2e8f0;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .connection-status {
            text-align: center;
            margin: 10px 0;
            font-size: 0.9em;
            padding: 8px;
            border-radius: 5px;
        }

        .connection-online {
            background: #c6f6d5;
            color: #22543d;
        }

        .connection-offline {
            background: #fed7d7;
            color: #c53030;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Voice Emotion Detection</h1>
            <p>Real-time emotion analysis from your voice using AI</p>
        </div>

        <div class="connection-status hidden" id="connectionStatus">
            <span id="connectionText">Checking connection...</span>
        </div>

        <div class="controls">
            <button id="recordBtn" class="btn">
                <span id="recordIcon">üé§</span>
                <span id="recordText">Start Recording</span>
            </button>
            <button id="stopBtn" class="btn" disabled>
                <span>‚èπÔ∏è</span>
                <span>Stop Recording</span>
            </button>
        </div>

        <div class="file-upload">
            <input type="file" id="audioFile" class="file-input" accept="audio/*,.wav,.mp3,.m4a,.webm,.ogg">
            <label for="audioFile" class="file-label">
                üìÅ Upload Audio File
            </label>
        </div>

        <div class="audio-visualizer" id="visualizer">
            <div class="wave-bars" id="waveBars" style="display: none;">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
            <div id="visualizerText">Click "Start Recording" or upload an audio file</div>
        </div>

        <div class="status" id="status">Ready to analyze emotions</div>

        <div class="results hidden" id="results">
            <div class="emotion-display" id="primaryEmotion">
                <div class="current-emotion" id="currentEmotion">-</div>
                <div class="confidence">Confidence: <span id="confidenceValue">0%</span></div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                </div>
            </div>
            
            <div class="emotion-bars-title">All Emotion Probabilities</div>
            <div class="emotion-bars" id="emotionBars">
                <!-- Emotion bars will be populated here -->
            </div>
        </div>

        <div class="message error hidden" id="error"></div>
        <div class="message info hidden" id="info"></div>
        <div class="message success hidden" id="success"></div>
    </div>

    <script>
        class VoiceEmotionUI {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.apiBaseUrl = 'http://localhost:5000';
                this.apiConnected = false;
                this.connectionCheckInterval = null;
                this.currentPrimaryEmotion = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.checkAPIHealth();
                this.startConnectionMonitoring();
            }
            
            initializeElements() {
                this.recordBtn = document.getElementById('recordBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.audioFile = document.getElementById('audioFile');
                this.visualizer = document.getElementById('visualizer');
                this.waveBars = document.getElementById('waveBars');
                this.visualizerText = document.getElementById('visualizerText');
                this.status = document.getElementById('status');
                this.results = document.getElementById('results');
                this.error = document.getElementById('error');
                this.info = document.getElementById('info');
                this.success = document.getElementById('success');
                this.currentEmotion = document.getElementById('currentEmotion');
                this.confidenceValue = document.getElementById('confidenceValue');
                this.confidenceFill = document.getElementById('confidenceFill');
                this.emotionBars = document.getElementById('emotionBars');
                this.recordIcon = document.getElementById('recordIcon');
                this.recordText = document.getElementById('recordText');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.connectionText = document.getElementById('connectionText');
                this.primaryEmotion = document.getElementById('primaryEmotion');
            }
            
            setupEventListeners() {
                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.audioFile.addEventListener('change', (e) => this.handleFileUpload(e));
                
                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.isRecording) {
                        console.log('Page hidden while recording, stopping...');
                        this.stopRecording();
                    }
                });
            }
            
            startConnectionMonitoring() {
                // Check connection every 30 seconds
                this.connectionCheckInterval = setInterval(() => {
                    this.checkAPIHealth(true);
                }, 30000);
            }
            
            async checkAPIHealth(silent = false) {
                try {
                    if (!silent) {
                        this.showStatus('Checking API connection...');
                        this.connectionStatus.classList.remove('hidden');
                    }
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                    
                    const response = await fetch(`${this.apiBaseUrl}/health`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.apiConnected = true;
                        this.supportedEmotions = data.supported_emotions || 
                            ['neutral', 'calm', 'happy', 'sad', 'angry', 'fearful', 'disgust', 'surprised'];
                        
                        this.updateConnectionStatus(true, `API connected - Model loaded: ${data.model_loaded}`);
                        
                        if (!silent) {
                            this.showSuccess(`API connected - Model loaded: ${data.model_loaded}`);
                        }
                        
                        this.createEmotionBars();
                    } else {
                        throw new Error(`API responded with status: ${response.status}`);
                    }
                } catch (error) {
                    console.log('API connection failed:', error);
                    this.apiConnected = false;
                    this.supportedEmotions = ['neutral', 'calm', 'happy', 'sad', 'angry', 'fearful', 'disgust', 'surprised'];
                    
                    this.updateConnectionStatus(false, 'API connection failed. Running in demo mode.');
                    
                    if (!silent) {
                        this.showInfo('API connection failed. Running in demo mode - upload files or record audio to see simulated emotion detection.');
                    }
                    
                    this.createEmotionBars();
                }
            }
            
            updateConnectionStatus(connected, message) {
                this.connectionStatus.classList.remove('hidden');
                this.connectionText.textContent = message;
                
                if (connected) {
                    this.connectionStatus.className = 'connection-status connection-online';
                } else {
                    this.connectionStatus.className = 'connection-status connection-offline';
                }
            }
            
            createEmotionBars() {
                if (!this.emotionBars) return;
                
                this.emotionBars.innerHTML = '';
                this.supportedEmotions.forEach(emotion => {
                    const barContainer = document.createElement('div');
                    barContainer.className = 'emotion-bar';
                    barContainer.innerHTML = `
                        <div class="emotion-label">${emotion}</div>
                        <div class="bar-container">
                            <div class="bar-fill emotion-${emotion}" style="width: 0%">
                                <div class="bar-text">0%</div>
                            </div>
                        </div>
                    `;
                    this.emotionBars.appendChild(barContainer);
                });
            }
            
            async startRecording() {
                try {
                    this.hideMessages();
                    this.showStatus('Requesting microphone access...');
                    
                    // Check if getUserMedia is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia is not supported in this browser');
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 22050
                        } 
                    });
                    
                    // Check for supported MIME types
                    const supportedTypes = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4',
                        'audio/ogg',
                        ''  // Let browser choose
                    ];
                    
                    let mimeType = '';
                    for (const type of supportedTypes) {
                        if (!type || MediaRecorder.isTypeSupported(type)) {
                            mimeType = type;
                            break;
                        }
                    }
                    
                    console.log('Using MIME type:', mimeType || 'browser default');
                    
                    this.mediaRecorder = new MediaRecorder(stream, 
                        mimeType ? { mimeType: mimeType } : {}
                    );
                    
                    this.audioChunks = [];
                    this.isRecording = true;
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        this.showError('Recording error: ' + event.error);
                        this.resetRecordingUI();
                    };
                    
                    this.mediaRecorder.start(1000); // Collect data every second
                    
                    // Update UI
                    this.recordBtn.disabled = true;
                    this.recordBtn.classList.add('recording');
                    this.recordIcon.textContent = 'üî¥';
                    this.recordText.textContent = 'Recording...';
                    this.stopBtn.disabled = false;
                    
                    this.showWaveAnimation();
                    this.showStatus('Recording... Speak into your microphone');
                    
                } catch (error) {
                    console.error('Microphone access error:', error);
                    let errorMessage = 'Could not access microphone. ';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please grant microphone permissions and try again.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No microphone found. Please connect a microphone and try again.';
                    } else {
                        errorMessage += error.message || 'Please check your microphone settings.';
                    }
                    
                    this.showError(errorMessage);
                    this.resetRecordingUI();
                }
            }
            
            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.isRecording = false;
                    
                    this.resetRecordingUI();
                    this.hideWaveAnimation();
                    this.showStatus('Processing audio...');
                }
            }
            
            resetRecordingUI() {
                this.recordBtn.disabled = false;
                this.recordBtn.classList.remove('recording');
                this.recordIcon.textContent = 'üé§';
                this.recordText.textContent = 'Start Recording';
                this.stopBtn.disabled = true;
            }
            
            async processRecording() {
                try {
                    if (this.audioChunks.length === 0) {
                        this.showError('No audio data recorded. Please try recording again.');
                        return;
                    }
                    
                    const audioBlob = new Blob(this.audioChunks, { 
                        type: this.mediaRecorder.mimeType || 'audio/webm' 
                    });
                    
                    if (audioBlob.size === 0) {
                        this.showError('Recorded audio is empty. Please try recording again.');
                        return;
                    }
                    
                    console.log(`Processing ${audioBlob.size} bytes of audio data`);
                    
                    if (this.apiConnected) {
                        await this.sendToAPI('/predict_stream', audioBlob);
                    } else {
                        await this.simulateEmotionDetection();
                    }
                    
                } catch (error) {
                    console.error('Recording processing error:', error);
                    this.showError('Failed to process recording: ' + error.message);
                }
            }
            
            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.hideMessages();
                this.showStatus('Validating uploaded file...');
                
                // Enhanced file validation
                const maxSize = 100 * 1024 * 1024; // 100MB limit
                const allowedTypes = ['audio/', 'video/'];
                
                if (file.size > maxSize) {
                    this.showError('File too large. Please select a file smaller than 100MB.');
                    this.clearFileInput(event);
                    return;
                }
                
                if (file.size === 0) {
                    this.showError('Selected file is empty. Please choose a valid audio file.');
                    this.clearFileInput(event);
                    return;
                }
                
                const isValidType = allowedTypes.some(type => file.type.startsWith(type));
                if (!isValidType && file.type) {
                    this.showError('Please select a valid audio file (wav, mp3, m4a, webm, ogg, etc.)');
                    this.clearFileInput(event);
                    return;
                }
                
                console.log(`Processing file: ${file.name}, size: ${file.size} bytes, type: ${file.type}`);
                this.showStatus(`Processing uploaded file: ${file.name}...`);
                
                try {
                    if (this.apiConnected) {
                        const formData = new FormData();
                        formData.append('audio', file);
                        await this.sendToAPI('/predict_file', formData, true);
                    } else {
                        await this.simulateEmotionDetection();
                    }
                } catch (error) {
                    console.error('File upload error:', error);
                    this.showError('Failed to process file: ' + error.message);
                } finally {
                    this.clearFileInput(event);
                }
            }
            
            clearFileInput(event) {
                event.target.value = '';
            }
            
            async sendToAPI(endpoint, data, isFormData = false) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                    
                    const options = {
                        method: 'POST',
                        body: data,
                        signal: controller.signal
                    };
                    
                    if (!isFormData) {
                        options.headers = {
                            'Content-Type': 'audio/webm'
                        };
                    }
                    
                    this.showStatus('Sending to AI for analysis...');
                    
                    const response = await fetch(`${this.apiBaseUrl}${endpoint}`, options);
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        if (result.error) {
                            throw new Error(result.error);
                        }
                        
                        this.displayResults(result);
                    } else {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMsg = errorData.error || `API error: ${response.status} ${response.statusText}`;
                        throw new Error(errorMsg);
                    }
                    
                } catch (error) {
                    console.error('API request error:', error);
                    
                    if (error.name === 'AbortError') {
                        this.showError('Request timed out. Please try with a shorter audio file.');
                    } else {
                        this.showInfo('API processing failed. Switching to demo mode...');
                        await this.simulateEmotionDetection();
                    }
                }
            }
            
            async simulateEmotionDetection() {
                try {
                    this.showStatus('Analyzing audio (demo mode)...');
                    
                    // Show loading spinner
                    this.status.innerHTML = `
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Analyzing audio (demo mode)...</span>
                        </div>
                    `;
                    
                    // Simulate processing delay
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Generate realistic emotion predictions with one clearly dominant emotion
                    const emotions = this.supportedEmotions;
                    const predictions = {};
                    
                    // Create realistic distribution with one dominant emotion
                    const dominantEmotion = emotions[Math.floor(Math.random() * emotions.length)];
                    const dominantConfidence = 0.50 + Math.random() * 0.35; // 50-85%
                    
                    let remainingProbability = 1 - dominantConfidence;
                    
                    emotions.forEach(emotion => {
                        if (emotion === dominantEmotion) {
                            predictions[emotion] = dominantConfidence;
                        } else {
                            // Distribute remaining probability among other emotions more evenly but smaller
                            const maxShare = remainingProbability / (emotions.length - 1) * 1.2;
                            const randomShare = Math.random() * maxShare;
                            predictions[emotion] = Math.min(randomShare, remainingProbability);
                            remainingProbability = Math.max(0, remainingProbability - predictions[emotion]);
                        }
                    });
                    
                    // Normalize to ensure sum equals 1
                    const total = Object.values(predictions).reduce((sum, val) => sum + val, 0);
                    Object.keys(predictions).forEach(emotion => {
                        predictions[emotion] /= total;
                    });
                    
                    const result = {
                        emotion: dominantEmotion,
                        confidence: predictions[dominantEmotion],
                        all_predictions: predictions
                    };
                    
                    console.log('Demo result:', result);
                    
                    this.displayResults(result);
                    
                } catch (error) {
                    console.error('Demo simulation error:', error);
                    this.showError('Failed to simulate emotion detection: ' + error.message);
                }
            }
            
            displayResults(result) {
                try {
                    this.hideMessages();
                    
                    // Clear any loading/processing status FIRST
                    this.showStatus('Analysis complete!');
                    
                    // Validate result structure
                    if (!result || !result.emotion || !result.all_predictions) {
                        this.showError('Invalid result format received');
                        return;
                    }
                    
                    // Find the actual highest confidence emotion to ensure consistency
                    let highestEmotion = result.emotion;
                    let highestConfidence = result.confidence || 0;
                    
                    // Double-check by finding the actual highest value in predictions
                    Object.entries(result.all_predictions).forEach(([emotion, confidence]) => {
                        if (confidence > highestConfidence) {
                            highestEmotion = emotion;
                            highestConfidence = confidence;
                        }
                    });
                    
                    // Update the primary emotion display
                    this.currentPrimaryEmotion = highestEmotion;
                    
                    // Show main emotion with emoji
                    const emotionEmojis = {
                        'happy': 'üòä',
                        'sad': 'üò¢',
                        'angry': 'üò†',
                        'fearful': 'üò®',
                        'surprised': 'üò≤',
                        'disgust': 'ü§¢',
                        'calm': 'üòå',
                        'neutral': 'üòê'
                    };
                    
                    this.currentEmotion.textContent = `${emotionEmojis[highestEmotion] || ''} ${highestEmotion}`;
                    this.confidenceValue.textContent = Math.round(highestConfidence * 100) + '%';
                    
                    // Animate confidence bar
                    setTimeout(() => {
                        this.confidenceFill.style.width = Math.round(highestConfidence * 100) + '%';
                    }, 300);
                    
                    // Add visual emphasis to primary emotion display
                    this.primaryEmotion.classList.add('primary-emotion');
                    
                    // Clear all bars first and reset classes
                    this.supportedEmotions.forEach(emotion => {
                        const barContainer = document.querySelector(`.emotion-bar`);
                        if (barContainer) {
                            barContainer.classList.remove('primary');
                        }
                        
                        const barFill = document.querySelector(`.emotion-${emotion} .bar-fill`);
                        const barText = document.querySelector(`.emotion-${emotion} .bar-text`);
                        if (barFill && barText) {
                            barFill.style.width = '0%';
                            barText.textContent = '0%';
                        }
                    });
                    
                    // Sort emotions by confidence for better display
                    const sortedEmotions = Object.entries(result.all_predictions)
                        .sort(([,a], [,b]) => b - a);
                    
                    // Update emotion bars with staggered animation
                    sortedEmotions.forEach(([emotion, confidence], index) => {
                        const barFill = document.querySelector(`.emotion-${emotion} .bar-fill`);
                        const barText = document.querySelector(`.emotion-${emotion} .bar-text`);
                        const barContainer = document.querySelector(`.emotion-bar`);
                        
                        if (barFill && barText) {
                            const percentage = Math.round(confidence * 100);
                            
                            // Highlight the primary emotion
                            if (emotion === highestEmotion && barContainer) {
                                setTimeout(() => {
                                    barContainer.classList.add('primary');
                                }, 300);
                            }
                            
                            // Animate the bar fill with staggered delay
                            setTimeout(() => {
                                barFill.style.width = percentage + '%';
                                barText.textContent = percentage + '%';
                            }, 400 + (index * 100)); // Stagger by 100ms
                        }
                    });
                    
                    // Show results with animation
                    this.results.classList.remove('hidden');
                    
                    // Show success message
                    setTimeout(() => {
                        this.showSuccess(`Primary emotion detected: ${highestEmotion} (${Math.round(highestConfidence * 100)}% confidence)`);
                        this.showStatus('Ready to analyze emotions');
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error displaying results:', error);
                    this.showError('Failed to display results: ' + error.message);
                }
            }
            
            showWaveAnimation() {
                this.visualizerText.style.display = 'none';
                this.waveBars.style.display = 'flex';
            }
            
            hideWaveAnimation() {
                this.visualizerText.style.display = 'block';
                this.waveBars.style.display = 'none';
                this.visualizerText.textContent = 'Click "Start Recording" or upload an audio file';
            }
            
            showStatus(message) {
                this.status.innerHTML = message;
                this.status.style.color = '#4a5568';
            }
            
            showError(message) {
                this.hideMessages();
                this.error.textContent = message;
                this.error.classList.remove('hidden');
                this.showStatus('Error occurred');
            }
            
            showInfo(message) {
                this.hideMessages();
                this.info.textContent = message;
                this.info.classList.remove('hidden');
            }
            
            showSuccess(message) {
                this.hideMessages();
                this.success.textContent = message;
                this.success.classList.remove('hidden');
            }
            
            hideMessages() {
                this.error.classList.add('hidden');
                this.info.classList.add('hidden');
                this.success.classList.add('hidden');
            }
            
            // Cleanup method
            destroy() {
                if (this.connectionCheckInterval) {
                    clearInterval(this.connectionCheckInterval);
                }
                
                if (this.isRecording) {
                    this.stopRecording();
                }
            }
        }
        
        // Initialize the application when DOM is loaded
        let voiceEmotionUI = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            try {
                voiceEmotionUI = new VoiceEmotionUI();
                console.log('Voice Emotion UI initialized successfully');
            } catch (error) {
                console.error('Failed to initialize Voice Emotion UI:', error);
                document.getElementById('status').textContent = 'Failed to initialize application: ' + error.message;
            }
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (voiceEmotionUI) {
                voiceEmotionUI.destroy();
            }
        });
    </script>
</body>
</html>